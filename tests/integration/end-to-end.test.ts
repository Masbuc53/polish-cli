import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import * as fs from 'fs/promises';
import * as path from 'path';
import { Polish } from '../../src/index.js';
import { ConfigService } from '../../src/services/ConfigService.js';
import { Config } from '../../src/types/index.js';
import { getTempDir, createTestFiles } from '../setup.js';

describe('End-to-End Integration Tests', () => {
  let tempDir: string;
  let config: Config;
  let configService: ConfigService;
  let polish: Polish;

  beforeEach(async () => {
    tempDir = getTempDir('e2e-test');
    await fs.mkdir(tempDir, { recursive: true });

    // Mock HOME directory for config service
    process.env.HOME = tempDir;

    configService = new ConfigService();
    config = {
      vault: {
        path: path.join(tempDir, 'vault'),
        structure: {
          documents: 'Documents',
          media: 'Media',
          code: 'Code',
          references: 'References',
        },
      },
      originals: {
        path: path.join(tempDir, 'organized'),
        organizationStyle: 'type-based',
        createYearFolders: true,
      },
      sources: [
        {
          path: path.join(tempDir, 'inbox'),
          includeSubfolders: true,
        },
      ],
      processing: {
        extractText: true,
        maxFileSize: '50MB',
        supportedFormats: ['txt', 'md', 'py', 'js', 'json', 'png', 'jpg'],
      },
      tagging: {
        maxTags: 10,
        autoGenerateTypeTags: true,
        autoGenerateDateTags: true,
        customTagPatterns: {},
      },
      api: {
        mode: 'claude-code',
        apiKey: 'test-key',
      },
    };

    await configService.save(config);
    polish = new Polish(config);
  });

  afterEach(async () => {
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  it('should perform complete file organization workflow', async () => {
    // Create a realistic set of files
    await createTestFiles([
      {
        path: path.join(tempDir, 'inbox', 'meeting-notes-q1-2024.txt'),
        content: 'Meeting notes from Q1 2024 planning session.\n\nAgenda:\n1. Budget review\n2. Project updates\n3. Team assignments',
      },
      {
        path: path.join(tempDir, 'inbox', 'project', 'data-analysis.py'),
        content: '#!/usr/bin/env python3\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef load_data(filename):\n    """Load CSV data"""\n    return pd.read_csv(filename)\n\ndef generate_report(df):\n    """Generate analysis report"""\n    return df.describe()\n\nif __name__ == "__main__":\n    data = load_data("sales.csv")\n    report = generate_report(data)\n    print(report)',
      },
      {
        path: path.join(tempDir, 'inbox', 'config.json'),
        content: '{\n  "app_name": "Polish",\n  "version": "1.0.0",\n  "settings": {\n    "debug": false,\n    "log_level": "info"\n  }\n}',
      },
      {
        path: path.join(tempDir, 'inbox', 'images', 'architecture-diagram.png'),
        content: 'fake-png-content',
      },
      {
        path: path.join(tempDir, 'inbox', 'readme.md'),
        content: '# Project Documentation\n\nThis is a comprehensive guide to the project.\n\n## Features\n\n- Feature 1\n- Feature 2\n\n## Installation\n\n```bash\nnpm install\n```',
      },
    ]);

    // Run organization
    const result = await polish.organize({
      dryRun: false,
    });

    // Verify results
    expect(result.summary.total).toBe(5);
    expect(result.summary.successful).toBe(5);
    expect(result.summary.failed).toBe(0);

    // Verify vault structure was created
    const vaultExists = await fs.access(config.vault.path).then(() => true).catch(() => false);
    expect(vaultExists).toBe(true);

    // Verify organized files structure was created
    const organizedExists = await fs.access(config.originals.path).then(() => true).catch(() => false);
    expect(organizedExists).toBe(true);

    // Check specific file organization
    const processedFiles = result.processed;

    // Meeting notes should be in Documents
    const meetingNotes = processedFiles.find(p => p.original.name.includes('meeting-notes'));
    expect(meetingNotes).toBeDefined();
    expect(meetingNotes?.markdownPath).toContain('Documents');
    expect(meetingNotes?.tags).toContain('type/document');
    expect(meetingNotes?.tags).toContain('topic/meeting');
    expect(meetingNotes?.tags).toContain('topic/notes');

    // Python script should be in Code
    const pythonScript = processedFiles.find(p => p.original.name.includes('data-analysis'));
    expect(pythonScript).toBeDefined();
    expect(pythonScript?.markdownPath).toContain('Code');
    expect(pythonScript?.tags).toContain('type/code');
    expect(pythonScript?.tags).toContain('format/py');

    // JSON should be in References (data files go to references by default)
    const jsonFile = processedFiles.find(p => p.original.name.includes('config.json'));
    expect(jsonFile).toBeDefined();
    expect(jsonFile?.markdownPath).toContain('References');
    expect(jsonFile?.tags).toContain('type/data');

    // Image should be in Media
    const imageFile = processedFiles.find(p => p.original.name.includes('architecture-diagram'));
    expect(imageFile).toBeDefined();
    expect(imageFile?.markdownPath).toContain('Media');
    expect(imageFile?.tags).toContain('type/image');

    // Verify markdown content quality
    const pythonMarkdown = pythonScript?.content;
    expect(pythonMarkdown).toContain('## Key Functions');
    expect(pythonMarkdown).toContain('- `load_data`');
    expect(pythonMarkdown).toContain('- `generate_report`');
    expect(pythonMarkdown).toContain('```python');

    // Verify original files were moved correctly
    const currentYear = new Date().getFullYear();
    const documentsPath = path.join(config.originals.path, currentYear.toString(), 'Document');
    const codePath = path.join(config.originals.path, currentYear.toString(), 'Code');

    const docsExist = await fs.access(documentsPath).then(() => true).catch(() => false);
    const codeExists = await fs.access(codePath).then(() => true).catch(() => false);

    expect(docsExist).toBe(true);
    expect(codeExists).toBe(true);
  });

  it('should handle copy mode without moving original files', async () => {
    await createTestFiles([
      {
        path: path.join(tempDir, 'inbox', 'important-document.txt'),
        content: 'This document should be preserved in original location.',
      },
    ]);

    const result = await polish.organize({
      copy: true,
      dryRun: false,
    });

    expect(result.summary.successful).toBe(1);

    // Original file should still exist
    const originalExists = await fs.access(path.join(tempDir, 'inbox', 'important-document.txt'))
      .then(() => true)
      .catch(() => false);
    expect(originalExists).toBe(true);

    // Copy should exist in organized location
    const currentYear = new Date().getFullYear();
    const copyPath = path.join(config.originals.path, currentYear.toString(), 'Document', 'important-document.txt');
    const copyExists = await fs.access(copyPath).then(() => true).catch(() => false);
    expect(copyExists).toBe(true);

    // Markdown should exist in vault
    const markdownExists = await fs.access(path.join(config.vault.path, 'Documents', 'important-document.md'))
      .then(() => true)
      .catch(() => false);
    expect(markdownExists).toBe(true);
  });

  it('should handle various file types and generate appropriate tags', async () => {
    await createTestFiles([
      {
        path: path.join(tempDir, 'inbox', 'financial-report-2024.txt'),
        content: 'Q4 Financial Report\n\nRevenue: $1.2M\nExpenses: $800K\nProfit: $400K',
      },
      {
        path: path.join(tempDir, 'inbox', 'user-authentication.js'),
        content: 'const bcrypt = require("bcrypt");\n\nfunction hashPassword(password) {\n  return bcrypt.hash(password, 10);\n}\n\nmodule.exports = { hashPassword };',
      },
      {
        path: path.join(tempDir, 'inbox', 'api-response.json'),
        content: '{\n  "status": "success",\n  "data": {\n    "users": 150,\n    "active_sessions": 23\n  }\n}',
      },
    ]);

    const result = await polish.organize({ dryRun: false });

    expect(result.summary.successful).toBe(3);

    const financialReport = result.processed.find(p => p.original.name.includes('financial-report'));
    const authScript = result.processed.find(p => p.original.name.includes('user-authentication'));
    const apiData = result.processed.find(p => p.original.name.includes('api-response'));

    // Check financial report tags
    expect(financialReport?.tags).toContain('topic/financial');
    expect(financialReport?.tags).toContain('topic/report');
    expect(financialReport?.content).toContain('Q4 Financial Report');

    // Check auth script tags and content
    expect(authScript?.tags).toContain('topic/user');
    expect(authScript?.tags).toContain('topic/authentication');
    expect(authScript?.content).toContain('## Key Functions');
    expect(authScript?.content).toContain('- `hashPassword`');

    // Check API data
    expect(apiData?.tags).toContain('type/data');
    expect(apiData?.tags).toContain('format/json');
  });

  it('should create proper vault folder structure', async () => {
    await createTestFiles([
      { path: path.join(tempDir, 'inbox', 'doc.txt'), content: 'Document content' },
      { path: path.join(tempDir, 'inbox', 'script.py'), content: 'print("hello")' },
      { path: path.join(tempDir, 'inbox', 'image.png'), content: 'image data' },
      { path: path.join(tempDir, 'inbox', 'data.json'), content: '{}' },
    ]);

    await polish.organize({ dryRun: false });

    // Check that all expected vault folders were created
    const documentsPath = path.join(config.vault.path, 'Documents');
    const codePath = path.join(config.vault.path, 'Code');
    const mediaPath = path.join(config.vault.path, 'Media');
    const referencesPath = path.join(config.vault.path, 'References');

    const [docsExist, codeExists, mediaExists, refsExist] = await Promise.all([
      fs.access(documentsPath).then(() => true).catch(() => false),
      fs.access(codePath).then(() => true).catch(() => false),
      fs.access(mediaPath).then(() => true).catch(() => false),
      fs.access(referencesPath).then(() => true).catch(() => false),
    ]);

    expect(docsExist).toBe(true);
    expect(codeExists).toBe(true);
    expect(mediaExists).toBe(true);
    expect(refsExist).toBe(true);

    // Verify files are in correct folders
    const docFiles = await fs.readdir(documentsPath);
    const codeFiles = await fs.readdir(codePath);
    const mediaFiles = await fs.readdir(mediaPath);
    const refFiles = await fs.readdir(referencesPath);

    expect(docFiles).toContain('doc.md');
    expect(codeFiles).toContain('script.md');
    expect(mediaFiles).toContain('image.md');
    expect(refFiles).toContain('data.md');
  });

  it('should generate comprehensive frontmatter', async () => {
    await createTestFiles([
      {
        path: path.join(tempDir, 'inbox', 'complex-document.txt'),
        content: 'This is a complex document with multiple sections.',
      },
    ]);

    const result = await polish.organize({ dryRun: false });
    const processed = result.processed[0];

    expect(processed.frontmatter.title).toBe('complex-document');
    expect(processed.frontmatter.originalFile).toContain('file://');
    expect(processed.frontmatter.fileType).toBe('txt');
    expect(processed.frontmatter.created).toBeDefined();
    expect(processed.frontmatter.processed).toBeDefined();
    expect(processed.frontmatter.tags).toBeInstanceOf(Array);
    expect(processed.frontmatter.tags.length).toBeGreaterThan(0);

    // Verify markdown contains frontmatter
    expect(processed.content).toContain('---');
    expect(processed.content).toContain('title: "complex-document"');
    expect(processed.content).toContain('tags:');
    expect(processed.content).toContain('  - type/document');
  });
});