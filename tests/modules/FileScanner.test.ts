import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import * as fs from 'fs/promises';
import * as path from 'path';
import { FileScanner } from '../../src/modules/FileScanner.js';
import { Config, FileType } from '../../src/types/index.js';
import { getTempDir, createTestFiles } from '../setup.js';

describe('FileScanner', () => {
  let fileScanner: FileScanner;
  let tempDir: string;
  let config: Config;

  beforeEach(async () => {
    tempDir = getTempDir('scanner-test');
    await fs.mkdir(tempDir, { recursive: true });

    config = {
      vault: {
        path: path.join(tempDir, 'vault'),
        structure: {
          documents: 'Documents',
          media: 'Media',
          code: 'Code',
          references: 'References',
        },
      },
      originals: {
        path: path.join(tempDir, 'originals'),
        organizationStyle: 'type-based',
        createYearFolders: true,
      },
      sources: [
        {
          path: path.join(tempDir, 'source1'),
          includeSubfolders: false,
        },
        {
          path: path.join(tempDir, 'source2'),
          includeSubfolders: true,
        },
      ],
      processing: {
        extractText: true,
        maxFileSize: '50MB',
        supportedFormats: ['pdf', 'docx', 'txt', 'md', 'png', 'jpg', 'py', 'js'],
      },
      tagging: {
        maxTags: 10,
        autoGenerateTypeTags: true,
        autoGenerateDateTags: true,
        customTagPatterns: {},
      },
      api: {
        mode: 'claude-code',
        apiKey: 'test-key',
      },
    };

    fileScanner = new FileScanner(config);
  });

  afterEach(async () => {
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('scan', () => {
    it('should scan files from source directories', async () => {
      // Create test files
      await createTestFiles([
        { path: path.join(tempDir, 'source1', 'document.pdf'), content: 'PDF content' },
        { path: path.join(tempDir, 'source1', 'image.png'), content: 'PNG content' },
        { path: path.join(tempDir, 'source1', 'script.py'), content: 'print("hello")' },
        { path: path.join(tempDir, 'source1', 'unsupported.xyz'), content: 'unsupported' },
      ]);

      const files = await fileScanner.scan(config.sources);

      expect(files).toHaveLength(3); // Only supported formats
      expect(files.map(f => f.name)).toContain('document.pdf');
      expect(files.map(f => f.name)).toContain('image.png');
      expect(files.map(f => f.name)).toContain('script.py');
      expect(files.map(f => f.name)).not.toContain('unsupported.xyz');
    });

    it('should respect includeSubfolders setting', async () => {
      // Create files in subdirectories
      await createTestFiles([
        { path: path.join(tempDir, 'source1', 'root.txt'), content: 'root file' },
        { path: path.join(tempDir, 'source1', 'sub', 'nested.txt'), content: 'nested file' },
        { path: path.join(tempDir, 'source2', 'root.txt'), content: 'root file' },
        { path: path.join(tempDir, 'source2', 'sub', 'nested.txt'), content: 'nested file' },
      ]);

      const files = await fileScanner.scan(config.sources);

      // source1 should not include subfolders, source2 should
      const source1Files = files.filter(f => f.path.includes('source1'));
      const source2Files = files.filter(f => f.path.includes('source2'));

      expect(source1Files).toHaveLength(1);
      expect(source1Files[0].name).toBe('root.txt');

      expect(source2Files).toHaveLength(2);
      expect(source2Files.map(f => f.name)).toContain('root.txt');
      expect(source2Files.map(f => f.name)).toContain('nested.txt');
    });

    it('should filter by file types when specified', async () => {
      await createTestFiles([
        { path: path.join(tempDir, 'source1', 'document.pdf'), content: 'PDF content' },
        { path: path.join(tempDir, 'source1', 'image.png'), content: 'PNG content' },
        { path: path.join(tempDir, 'source1', 'script.py'), content: 'Python code' },
        { path: path.join(tempDir, 'source1', 'text.txt'), content: 'Text content' },
      ]);

      const files = await fileScanner.scan(config.sources, ['pdf', 'png']);

      expect(files).toHaveLength(2);
      expect(files.map(f => f.extension)).toContain('pdf');
      expect(files.map(f => f.extension)).toContain('png');
      expect(files.map(f => f.extension)).not.toContain('py');
      expect(files.map(f => f.extension)).not.toContain('txt');
    });

    it('should correctly identify file types', async () => {
      await createTestFiles([
        { path: path.join(tempDir, 'source1', 'document.pdf'), content: 'PDF' },
        { path: path.join(tempDir, 'source1', 'image.png'), content: 'PNG' },
        { path: path.join(tempDir, 'source1', 'script.py'), content: 'Python' },
        { path: path.join(tempDir, 'source1', 'data.json'), content: '{}' },
        { path: path.join(tempDir, 'source1', 'archive.zip'), content: 'ZIP' },
      ]);

      const files = await fileScanner.scan(config.sources);

      const pdfFile = files.find(f => f.extension === 'pdf');
      const pngFile = files.find(f => f.extension === 'png');
      const pyFile = files.find(f => f.extension === 'py');
      const jsonFile = files.find(f => f.extension === 'json');
      const zipFile = files.find(f => f.extension === 'zip');

      expect(pdfFile?.type).toBe(FileType.Document);
      expect(pngFile?.type).toBe(FileType.Image);
      expect(pyFile?.type).toBe(FileType.Code);
      expect(jsonFile?.type).toBe(FileType.Data);
      expect(zipFile?.type).toBe(FileType.Archive);
    });

    it('should handle non-existent directories gracefully', async () => {
      const sources = [
        { path: path.join(tempDir, 'non-existent'), includeSubfolders: false },
      ];

      const files = await fileScanner.scan(sources);
      expect(files).toHaveLength(0);
    });

    it('should ignore hidden files and directories', async () => {
      await createTestFiles([
        { path: path.join(tempDir, 'source1', 'visible.txt'), content: 'visible' },
        { path: path.join(tempDir, 'source1', '.hidden.txt'), content: 'hidden' },
        { path: path.join(tempDir, 'source1', '.git', 'config'), content: 'git config' },
        { path: path.join(tempDir, 'source1', 'node_modules', 'package.json'), content: '{}' },
      ]);

      const files = await fileScanner.scan(config.sources);

      expect(files).toHaveLength(1);
      expect(files[0].name).toBe('visible.txt');
    });
  });

  describe('file metadata extraction', () => {
    it('should extract correct file metadata', async () => {
      const testFile = path.join(tempDir, 'source1', 'test.txt');
      await createTestFiles([{ path: testFile, content: 'test content' }]);

      const files = await fileScanner.scan(config.sources);
      const file = files[0];

      expect(file.name).toBe('test.txt');
      expect(file.extension).toBe('txt');
      expect(file.size).toBeGreaterThan(0);
      expect(file.createdAt).toBeInstanceOf(Date);
      expect(file.modifiedAt).toBeInstanceOf(Date);
      expect(file.type).toBe(FileType.Document);
      expect(file.path).toBe(testFile);
    });
  });
});