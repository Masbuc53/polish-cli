import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import * as fs from 'fs/promises';
import * as path from 'path';
import { Polish } from '../src/index.js';
import { Config } from '../src/types/index.js';
import { getTempDir, createTestFiles } from './setup.js';

describe('Polish (Main Class)', () => {
  let polish: Polish;
  let tempDir: string;
  let config: Config;

  beforeEach(async () => {
    tempDir = getTempDir('polish-test');
    await fs.mkdir(tempDir, { recursive: true });

    config = {
      vault: {
        path: path.join(tempDir, 'vault'),
        structure: {
          documents: 'Documents',
          media: 'Media',
          code: 'Code',
          references: 'References',
        },
      },
      originals: {
        path: path.join(tempDir, 'originals'),
        organizationStyle: 'type-based',
        createYearFolders: true,
      },
      sources: [
        {
          path: path.join(tempDir, 'source'),
          includeSubfolders: false,
        },
      ],
      processing: {
        extractText: true,
        maxFileSize: '50MB',
        supportedFormats: ['txt', 'md', 'py', 'js', 'json'],
      },
      tagging: {
        maxTags: 10,
        autoGenerateTypeTags: true,
        autoGenerateDateTags: true,
        customTagPatterns: {},
      },
      api: {
        mode: 'claude-code',
        apiKey: 'test-key',
      },
    };

    polish = new Polish(config);
  });

  afterEach(async () => {
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('initialization', () => {
    it('should initialize with default config when no config provided', () => {
      const polishDefault = new Polish();
      expect(polishDefault).toBeDefined();
    });

    it('should initialize with custom config', () => {
      const customConfig = {
        vault: { path: '/custom/vault' },
        api: { mode: 'api' as const },
      };
      const polishCustom = new Polish(customConfig);
      expect(polishCustom).toBeDefined();
    });
  });

  describe('organize', () => {
    it('should organize files in dry-run mode', async () => {
      // Create test files
      await createTestFiles([
        { path: path.join(tempDir, 'source', 'document.txt'), content: 'Test document content' },
        { path: path.join(tempDir, 'source', 'script.py'), content: 'print("Hello World")' },
        { path: path.join(tempDir, 'source', 'data.json'), content: '{"key": "value"}' },
      ]);

      const result = await polish.organize({
        dryRun: true,
      });

      expect(result.summary.total).toBe(3);
      expect(result.summary.successful).toBe(3);
      expect(result.summary.failed).toBe(0);
      expect(result.processed).toHaveLength(3);

      // Files should not actually be moved in dry-run mode
      const sourceFiles = await fs.readdir(path.join(tempDir, 'source'));
      expect(sourceFiles).toHaveLength(3);
    });

    it('should organize files and create markdown copies', async () => {
      // Create test files
      await createTestFiles([
        { path: path.join(tempDir, 'source', 'document.txt'), content: 'Test document content' },
        { path: path.join(tempDir, 'source', 'script.py'), content: 'def hello():\n    print("Hello World")' },
      ]);

      const result = await polish.organize({
        dryRun: false,
      });

      expect(result.summary.total).toBe(2);
      expect(result.summary.successful).toBe(2);
      expect(result.summary.failed).toBe(0);

      // Check that markdown files were created in vault
      const vaultExists = await fs.access(path.join(tempDir, 'vault')).then(() => true).catch(() => false);
      expect(vaultExists).toBe(true);

      // Check that original files were moved to organized location
      const originalsExists = await fs.access(path.join(tempDir, 'originals')).then(() => true).catch(() => false);
      expect(originalsExists).toBe(true);

      // Verify markdown content
      const docMarkdown = result.processed.find(p => p.original.name === 'document.txt');
      expect(docMarkdown).toBeDefined();
      expect(docMarkdown?.content).toContain('# document');
      expect(docMarkdown?.content).toContain('Test document content');
      expect(docMarkdown?.tags).toContain('type/document');
    });

    it('should handle copy mode correctly', async () => {
      await createTestFiles([
        { path: path.join(tempDir, 'source', 'document.txt'), content: 'Test content' },
      ]);

      const result = await polish.organize({
        copy: true,
        dryRun: false,
      });

      expect(result.summary.successful).toBe(1);

      // Original file should still exist when copying
      const originalExists = await fs.access(path.join(tempDir, 'source', 'document.txt')).then(() => true).catch(() => false);
      expect(originalExists).toBe(true);

      // Copy should exist in organized location
      const copyExists = await fs.access(path.join(tempDir, 'originals')).then(() => true).catch(() => false);
      expect(copyExists).toBe(true);
    });

    it('should handle progress callback', async () => {
      await createTestFiles([
        { path: path.join(tempDir, 'source', 'file1.txt'), content: 'Content 1' },
        { path: path.join(tempDir, 'source', 'file2.txt'), content: 'Content 2' },
      ]);

      const progressCalls: Array<{ current: number; total: number; fileName: string }> = [];

      await polish.organize({
        dryRun: true,
        onProgress: (current, total, file) => {
          progressCalls.push({ current, total, fileName: file.name });
        },
      });

      expect(progressCalls).toHaveLength(2);
      expect(progressCalls[0]).toEqual({ current: 1, total: 2, fileName: 'file1.txt' });
      expect(progressCalls[1]).toEqual({ current: 2, total: 2, fileName: 'file2.txt' });
    });

    it('should handle custom source directories', async () => {
      const customSource = path.join(tempDir, 'custom');
      await createTestFiles([
        { path: path.join(customSource, 'custom.txt'), content: 'Custom content' },
      ]);

      const result = await polish.organize({
        sources: [customSource],
        dryRun: true,
      });

      expect(result.summary.total).toBe(1);
      expect(result.processed[0].original.name).toBe('custom.txt');
    });

    it('should handle errors gracefully', async () => {
      // Create a file that will cause an error (e.g., permission denied)
      const problematicFile = path.join(tempDir, 'source', 'readonly.txt');
      await createTestFiles([
        { path: problematicFile, content: 'Test content' },
      ]);

      // Make file read-only by changing permissions
      await fs.chmod(problematicFile, 0o444);

      const result = await polish.organize({
        dryRun: false,
      });

      // Should handle the error and continue processing
      expect(result.summary.total).toBe(1);
      // Note: This test might pass differently on different systems
      // The important thing is that it doesn't crash
    });

    it('should organize files with tags based on content', async () => {
      await createTestFiles([
        { path: path.join(tempDir, 'source', 'meeting-notes.txt'), content: 'Meeting notes from January 2024' },
        { path: path.join(tempDir, 'source', 'project-code.py'), content: 'def calculate_total():\n    return sum([1, 2, 3])' },
      ]);

      const result = await polish.organize({
        dryRun: true,
      });

      expect(result.summary.successful).toBe(2);

      const meetingFile = result.processed.find(p => p.original.name === 'meeting-notes.txt');
      const codeFile = result.processed.find(p => p.original.name === 'project-code.py');

      expect(meetingFile?.tags).toContain('type/document');
      expect(meetingFile?.tags).toContain('format/txt');
      expect(meetingFile?.tags).toContain('topic/meeting');
      expect(meetingFile?.tags).toContain('topic/notes');

      expect(codeFile?.tags).toContain('type/code');
      expect(codeFile?.tags).toContain('format/py');
      expect(codeFile?.tags).toContain('topic/project');
      expect(codeFile?.tags).toContain('topic/code');
    });
  });

  describe('loadConfig', () => {
    it('should load configuration from file', async () => {
      // This test would require setting up a config file
      // For now, we'll just test that the method exists and handles missing config
      await expect(polish.loadConfig()).resolves.not.toThrow();
    });
  });
});