import { ProfileManager } from '../ProfileManager.js';
import { ConfigService } from '../ConfigService.js';
import fs from 'fs/promises';

// Mock dependencies
jest.mock('fs/promises');
jest.mock('../ConfigService.js');

const mockFs = fs as jest.Mocked<typeof fs>;
const mockConfigService = ConfigService as jest.MockedClass<typeof ConfigService>;

describe('ProfileManager', () => {
  let profileManager: ProfileManager;
  let mockConfigServiceInstance: jest.Mocked<ConfigService>;

  beforeEach(() => {
    // Clear all mocks
    jest.clearAllMocks();
    
    // Create mock config service instance
    mockConfigServiceInstance = {
      exists: jest.fn(),
      load: jest.fn(),
      save: jest.fn(),
      getDefaultConfig: jest.fn().mockReturnValue({
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      })
    } as any;
    
    mockConfigService.mockImplementation(() => mockConfigServiceInstance);
    
    // Create fresh ProfileManager instance
    profileManager = new ProfileManager();
  });

  describe('initialization', () => {
    it('should initialize with default configuration', async () => {
      mockFs.mkdir.mockResolvedValue(undefined);
      mockFs.readdir.mockResolvedValue(['existing-profile.json'] as any);
      mockFs.readFile.mockResolvedValue(JSON.stringify({
        name: 'existing-profile',
        description: 'Test profile',
        config: {
          vault: { path: '/test/vault', structure: { documents: 'Documents', media: 'Media', code: 'Code', references: 'References' } },
          originals: { path: '/test/originals', organizationStyle: 'type-based' as const, createYearFolders: true },
          sources: [],
          processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
          tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
          api: { mode: 'claude-code' as const }
        },
        createdAt: new Date().toISOString(),
        lastUsed: new Date().toISOString()
      }));

      await profileManager.initialize();

      expect(mockFs.mkdir).toHaveBeenCalled();
      expect(mockFs.readdir).toHaveBeenCalled();
    });

    it('should create profiles file if it does not exist', async () => {
      mockFs.access.mockRejectedValue(new Error('File not found'));
      mockFs.writeFile.mockResolvedValue(undefined);

      await profileManager.initialize();

      expect(mockFs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('profiles.json'),
        JSON.stringify({
          profiles: {},
          activeProfile: null
        }, null, 2)
      );
    });

    it('should migrate legacy configuration if present', async () => {
      mockFs.access.mockResolvedValueOnce(undefined); // profiles.json exists
      mockFs.readFile.mockResolvedValueOnce(JSON.stringify({
        profiles: {},
        activeProfile: null
      }));

      mockConfigServiceInstance.exists.mockResolvedValue(true);
      mockConfigServiceInstance.load.mockResolvedValue({
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      });

      mockFs.writeFile.mockResolvedValue(undefined);

      await profileManager.initialize();

      expect(mockFs.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('profiles.json'),
        expect.stringContaining('default')
      );
    });
  });

  describe('profile management', () => {
    beforeEach(async () => {
      mockFs.access.mockResolvedValue(undefined);
      mockFs.readFile.mockResolvedValue(JSON.stringify({
        profiles: {},
        activeProfile: null
      }));
      mockFs.writeFile.mockResolvedValue(undefined);
      
      await profileManager.initialize();
    });

    it('should create a new profile', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      const profile = await profileManager.createProfile('test', config, 'Test profile');

      expect(profile.name).toBe('test');
      expect(profile.description).toBe('Test profile');
      expect(profile.config).toEqual(config);
      expect(mockFs.writeFile).toHaveBeenCalled();
    });

    it('should throw error when creating duplicate profile', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test', config);

      await expect(profileManager.createProfile('test', config)).rejects.toThrow('Profile "test" already exists');
    });

    it('should retrieve an existing profile', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test', config, 'Test profile');
      const profile = await profileManager.getProfile('test');

      expect(profile).not.toBeNull();
      expect(profile!.name).toBe('test');
      expect(profile!.description).toBe('Test profile');
    });

    it('should return null for non-existent profile', async () => {
      const profile = await profileManager.getProfile('nonexistent');
      expect(profile).toBeNull();
    });

    it('should list all profiles', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test1', config, 'Test profile 1');
      await profileManager.createProfile('test2', config, 'Test profile 2');

      const profiles = await profileManager.listProfiles();

      expect(profiles).toHaveLength(2);
      expect(profiles.find(p => p.name === 'test1')).toBeDefined();
      expect(profiles.find(p => p.name === 'test2')).toBeDefined();
    });

    it('should set active profile', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test', config);
      await profileManager.setActiveProfile('test');

      const profiles = await profileManager.listProfiles();
      const testProfile = profiles.find(p => p.name === 'test');

      expect(testProfile!.isActive).toBe(true);
    });

    it('should throw error when setting non-existent profile as active', async () => {
      await expect(profileManager.setActiveProfile('nonexistent')).rejects.toThrow('Profile "nonexistent" not found');
    });

    it('should get active profile configuration', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test', config);
      await profileManager.setActiveProfile('test');

      const activeConfig = await profileManager.getActiveConfig();

      expect(activeConfig).toEqual(config);
    });

    it('should throw error when getting active config with no active profile', async () => {
      await expect(profileManager.getActiveConfig()).rejects.toThrow('No active profile set');
    });

    it('should delete a profile', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test', config);
      await profileManager.deleteProfile('test');

      const profile = await profileManager.getProfile('test');
      expect(profile).toBeNull();
    });

    it('should throw error when deleting non-existent profile', async () => {
      await expect(profileManager.deleteProfile('nonexistent')).rejects.toThrow('Profile "nonexistent" not found');
    });

    it('should update a profile', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test', config, 'Original description');

      const updatedConfig = {
        ...config,
        vault: { 
          path: '/updated/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        }
      };

      await profileManager.updateProfile('test', { 
        config: updatedConfig, 
        description: 'Updated description' 
      });

      const profile = await profileManager.getProfile('test');
      expect(profile!.description).toBe('Updated description');
      expect(profile!.config.vault.path).toBe('/updated/vault');
    });

    it('should clone a profile', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('original', config, 'Original profile');
      const clonedProfile = await profileManager.cloneProfile('original', 'clone', 'Cloned profile');

      expect(clonedProfile.name).toBe('clone');
      expect(clonedProfile.description).toBe('Cloned profile');
      expect(clonedProfile.config).toEqual(config);
    });
  });

  describe('profile import/export', () => {
    beforeEach(async () => {
      mockFs.access.mockResolvedValue(undefined);
      mockFs.readFile.mockResolvedValue(JSON.stringify({
        profiles: {},
        activeProfile: null
      }));
      mockFs.writeFile.mockResolvedValue(undefined);
      
      await profileManager.initialize();
    });

    it('should export profiles to file', async () => {
      const config = {
        vault: { 
          path: '/test/vault',
          structure: {
            documents: 'Documents',
            media: 'Media',
            code: 'Code',
            references: 'References'
          }
        },
        originals: { 
          path: '/test/originals',
          organizationStyle: 'type-based' as const,
          createYearFolders: true
        },
        sources: [],
        processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
        tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, customTagPatterns: {} },
        api: { mode: 'claude-code' as const }
      };

      await profileManager.createProfile('test', config, 'Test profile');
      await profileManager.exportProfiles('/export/path.json');

      expect(mockFs.writeFile).toHaveBeenCalledWith(
        '/export/path.json',
        expect.stringContaining('test')
      );
    });

    it('should import profiles from file', async () => {
      const importData = {
        profiles: {
          imported: {
            name: 'imported',
            description: 'Imported profile',
            config: {
              vault: { 
                path: '/imported/vault',
                structure: {
                  documents: 'Documents',
                  media: 'Media',
                  code: 'Code',
                  references: 'References'
                }
              },
              originals: { 
                path: '/imported/originals',
                organizationStyle: 'type-based' as const,
                createYearFolders: true,
                preserveStructure: false
              },
              sources: [],
              processing: { extractText: true, maxFileSize: '10MB', supportedFormats: [] },
              tagging: { maxTags: 8, autoGenerateTypeTags: true, autoGenerateDateTags: true, autoGenerateSourceTags: true, customTagPatterns: {}, excludeTags: [] },
              api: { mode: 'claude-code' as const, timeout: 30000, retries: 3 }
            },
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          }
        },
        activeProfile: 'imported'
      };

      mockFs.readFile.mockResolvedValueOnce(JSON.stringify(importData));

      await profileManager.importProfiles('/import/path.json');

      const profile = await profileManager.getProfile('imported');
      expect(profile).not.toBeNull();
      expect(profile!.name).toBe('imported');
      expect(profile!.description).toBe('Imported profile');
    });
  });

  describe('error handling', () => {
    it('should handle file system errors gracefully', async () => {
      mockFs.access.mockRejectedValue(new Error('Permission denied'));
      mockFs.writeFile.mockRejectedValue(new Error('Disk full'));

      await expect(profileManager.initialize()).rejects.toThrow();
    });

    it('should handle invalid JSON in profiles file', async () => {
      mockFs.access.mockResolvedValue(undefined);
      mockFs.readFile.mockResolvedValue('invalid json');

      await expect(profileManager.initialize()).rejects.toThrow();
    });
  });
});